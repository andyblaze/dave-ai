<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dave AI Example</title>
<style = "text/css">
    #nnCanvas {
        border:1px #000000 solid;
    }
</style>
</head>
<body>
<div>
  <label>Input Number: <input type="number" id="testInput" value="105" min="0" max="160" /></label>
  <button onclick="visualiser.run()">Visualize</button>
</div>

<canvas id="nnCanvas" width="800" height="800"></canvas>
<script type="text/javascript" src="dave.js"></script>
<script type="text/javascript">
     //create(3, 10); // x inputs, y hidden neurons
    
class Trainer { 
    constructor(net) {
        this.network = net;
    }
    trainYes(yes) {
        const input = encodeNumber(yes);
        this.network.train(input, 1);
    }
    trainNo(no) {
        const input = encodeNumber(no);
        this.network.train(input, 0);
    }
    /* symmetric training
    const yesValues = Array.from({ length: 2001 }, (_, i) => i * 5);
    const noValues = Array.from({ length: 10000 }, (_, i) => i).filter(n => n % 5 !== 0);
    */
    loop(net, count=60000) {
        const noValues = Array.from({ length: 10000 }, (_, i) => i).filter(n => n % 5 !== 0);
        for (let i = 0; i < count; i++) {
            const yes = mt_rand(0, 2000) * 5;
            this.trainYes(yes);
            const no = noValues[mt_rand(0, noValues.length -1)];
            this.trainNo(no);
        }
    }
}
class TestHarness {
    prediction(net) {
        let correct = 0;
        for (let i = 0; i < 10000; i++) {
            const output = net.predict(i);
            if ( isNaN(output) ) {
                throw new Error("NaN from predict(): " + output);
            }
            const isYes = i % 5 === 0;
            if ((isYes && output > 0.9) || (!isYes && output < 0.1)) {
                correct++;
            }
        }
        console.log("Accuracy: " + (correct / 100) + "%");    
    }
}

class Canvas {
    constructor(canvasID) {
        this.ctx = document.getElementById(canvasID).getContext('2d');
    }
    circle(x, y, r, fill) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI * 2);
        this.ctx.fillStyle = fill;
        this.ctx.fill();
        this.ctx.stroke();
    }
    text(txt, x, y) {
        this.ctx.fillStyle = 'black';
        this.ctx.font = "20px sans-serif";
        this.ctx.fillText(txt, x, y);
    }
    grid() {
        this.ctx.strokeStyle = "black";
        this.ctx.lineWidth = 1;
        for ( let i = 80; i < 800; i+=80 ) {
            // vertical lines
            this.ctx.beginPath();
            this.ctx.moveTo(i, 0);
            this.ctx.lineTo(i, 800);
            this.ctx.stroke();   
            // horizontal lines            
            this.ctx.beginPath();
            this.ctx.moveTo(0, i);
            this.ctx.lineTo(800, i);
            this.ctx.stroke();            
        }
    }
    clear() {
        this.ctx.clearRect(0, 0, 800, 800);
    }
}
class Visualiser {
    constructor(canvasID, w, h) {
        //this.ctx = document.getElementById(canvasID).getContext('2d');
        this.canvas = new Canvas(canvasID);
        this.width = w;
        this.height = h;
        this.circleRadius = 20;
    }
    setNetwork(n) {
        this.net = n;
    }
    setActivations(a) {
        this.acts = a;
    }
    valueToColor(v) {
        const red = Math.floor(v * 255);
        const blue = 255 - red;
        return `rgba(${red},0,${blue},0.5)`;
    }
    drawNeuron(x, y, value, label) {
        this.canvas.circle(x + this.circleRadius, y + this.circleRadius, this.circleRadius, this.valueToColor(value));
        this.canvas.text(label, x - this.circleRadius, y + 20);
        this.canvas.text(value.toFixed(2), x - this.circleRadius, y + this.circleRadius + 40);
    }
    grid() {
        const Xs = [20, 140, 180];
        const spacing = 0;
        const count = this.acts[2].values.length;
        const totalSpacing = spacing * (count - 1);
        const availableHeight = this.height - totalSpacing;
        const boxH = Math.floor(availableHeight / count);
        const boxW = 80;
        let boxes = [];
        for ( let i = 0; i < count; i++ )
            boxes.push({"x":140, "y":(i * boxH), "w":80, "h":80});
        console.log(boxes);
        return boxes;
    }
    run() {
        const number = parseInt(document.getElementById("testInput").value);
        this.setActivations(this.net.getActivations(number));
        this.canvas.clear();
        this.canvas.grid();
        // Draw input neurons
        this.acts[0].values.forEach((val, i) => {
            this.drawNeuron(50, 120 + i * 70, val, `I${i + 1}`);
        });
        // Draw hidden neurons
        const boxes = this.grid();
        this.acts[2].values.forEach((val, i) => {
            this.drawNeuron(boxes[i].x, boxes[i].y, val, `H${i + 1}`);
        });
        // Draw output neuron
        this.drawNeuron(330, 120, this.acts[1].values[0], 'Output');
    }
}
const net = new Dave(3, 10);
const trainer = new Trainer(net);
const test = new TestHarness();
const visualiser = new Visualiser("nnCanvas", 800, 800);
trainer.loop(net);
test.prediction(net);
visualiser.setNetwork(net);
  

</script>
</body>
</html>