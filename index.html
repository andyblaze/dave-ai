<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dave AI Example</title>
<style = "text/css">
    #nnCanvas {
        border:1px #000000 solid;
    }
</style>
</head>
<body>
<div>
  <label>Input Number: <input type="number" id="testInput" value="105" min="0" max="160" /></label>
  <button onclick="visualiser.run()">Visualize</button>
</div>

<canvas id="nnCanvas" width="800" height="800"></canvas>
<script type="text/javascript" src="dave.js"></script>
<script type="text/javascript">
    
class Trainer { 
    constructor(net) {
        this.network = net;
    }
    trainYes(yes) {
        const input = encodeNumber(yes);
        this.network.train(input, 1);
    }
    trainNo(no) {
        const input = encodeNumber(no);
        this.network.train(input, 0);
    }
    /* symmetric training
    const yesValues = Array.from({ length: 2001 }, (_, i) => i * 5);
    const noValues = Array.from({ length: 10000 }, (_, i) => i).filter(n => n % 5 !== 0);
    */
    loop(net, count=60000) {
        const noValues = Array.from({ length: 10000 }, (_, i) => i).filter(n => n % 5 !== 0);
        for (let i = 0; i < count; i++) {
            const yes = mt_rand(0, 2000) * 5;
            this.trainYes(yes);
            const no = noValues[mt_rand(0, noValues.length -1)];
            this.trainNo(no);
        }
    }
}
class TestHarness {
    prediction(net) {
        let correct = 0;
        for (let i = 0; i < 10000; i++) {
            const output = net.predict(i);
            if ( isNaN(output) ) {
                throw new Error("NaN from predict(): " + output);
            }
            const isYes = i % 5 === 0;
            if ((isYes && output > 0.9) || (!isYes && output < 0.1)) {
                correct++;
            }
        }
        console.log("Accuracy: " + (correct / 100) + "%");    
    }
}

class Canvas {
    constructor(canvasID, w, h) {
        this.ctx = document.getElementById(canvasID).getContext('2d');
        this.width = w;
        this.height = h;
    }
    circle(x, y, r, fill) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI * 2);
        this.ctx.fillStyle = fill;
        this.ctx.fill();
        this.ctx.stroke();
    }
    text(txt, x, y) {
        this.ctx.fillStyle = 'black';
        this.ctx.font = "20px sans-serif";
        this.ctx.fillText(txt, x, y);
    }
    grid() { // presuming width & height are equal
        this.ctx.strokeStyle = "black";
        this.ctx.lineWidth = 1;
        for ( let i = 80; i < this.width; i+=80 ) {
            // vertical lines
            this.ctx.beginPath();
            this.ctx.moveTo(i, 0);
            this.ctx.lineTo(i, this.width);
            this.ctx.stroke();   
            // horizontal lines            
            this.ctx.beginPath();
            this.ctx.moveTo(0, i);
            this.ctx.lineTo(this.width, i);
            this.ctx.stroke();            
        }
    }
    clear() {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }
}
class Visualiser {
    constructor(canvasID, w, h) {
        this.canvas = new Canvas(canvasID, w, h);
        this.width = w;
        this.height = h;
        this.circleRadius = 20;
    }
    setNetwork(n) {
        this.net = n;
    }
    valueToColor(v) {
        const red = Math.floor(v * 255);
        const blue = 255 - red;
        return `rgba(${red},0,${blue},0.5)`;
    }
    drawNeuron(x, y, value, label) {
        this.canvas.circle(x + this.circleRadius, y + this.circleRadius, this.circleRadius, this.valueToColor(value));
        //this.canvas.text(label, x - this.circleRadius, y + 20);
        this.canvas.text(value.toFixed(2), x, y + this.circleRadius + 40);
    }
    grid() {
        const Xs = [20, 140, 180];
        const spacing = 0;
        const count = this.layers[2].values.length;
        const totalSpacing = spacing * (count - 1);
        const availableHeight = this.height - totalSpacing;
        const boxH = Math.floor(availableHeight / count);
        const boxW = 80;
        let boxes = [];
        for ( let i = 0; i < count; i++ )
            boxes.push({"x":140, "y":(i * boxH), "w":80, "h":80});
        //console.log(boxes);
        return boxes;
    }
    drawLayer(layer) {
        this.canvas.text(layer.title, layer.x, layer.top);
        layer.values.forEach((val, i) => {
            this.drawNeuron(layer.x, (i * layer.boxSize) + layer.top + layer.headingHeight, val, `I${i + 1}`);
        });
    }
    run() {
        const number = parseInt(document.getElementById("testInput").value);
        let layers = this.net.getActivations(number);
        this.canvas.clear();
        //this.canvas.grid();
        const baseX = 20;
        const xShift = 110;
        const headingHeight = 25;
        const boxSize = 70;
        for ( let i = 0; i < layers.length; i++ ) {
            layers[i].count = layers[i].values.length;
            const layerHeight = layers[i].count * boxSize + headingHeight;
            const layerTop = Math.floor((this.height - layerHeight) / 2);
            let newData = {
                "x": i * xShift + baseX, "top": layerTop, "boxSize": boxSize, "headingHeight": headingHeight
            };
            Object.assign(layers[i], newData);
            this.drawLayer(layers[i]);
        }
    }
}
const net = new Dave(3, 10);
const trainer = new Trainer(net);
const test = new TestHarness();
const visualiser = new Visualiser("nnCanvas", 800, 800);
trainer.loop(net);
test.prediction(net);
visualiser.setNetwork(net);
  

</script>
</body>
</html>